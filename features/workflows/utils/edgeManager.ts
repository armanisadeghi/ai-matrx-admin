import { getAllKnownBrokers } from "./knownBrokersRegistry";
import { Edge } from "reactflow";
import { DbFunctionNode } from "@/features/workflows/types";

function toTitleCase(snakeCase: string): string {
    if (!snakeCase || typeof snakeCase !== "string") {
        return snakeCase || "";
    }
    return snakeCase
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(" ");
}

interface BrokerConnection {
    sourceBrokerId: string;
    sourceNodeId: string;
    targetNodeId: string;
    connectionType: "to_argument" | "to_relay" | "to_dependency";
    metadata?: {
        targetArgName?: string; // For argument connections
        relayLabel?: string; // For relay connections
        dependencyHasTarget?: boolean; // For dependency connections
        knownBrokerLabel?: string; // Label from known brokers registry
        knownBrokerDescription?: string; // Description from known brokers registry
    };
}

/**
 * Enhanced broker connection analyzer that considers known brokers
 * Starting with user inputs and now including runtime-generated brokers
 * Also processes basic database edges alongside virtual broker connections
 */
export function analyzeBrokerConnections(completeData: any): Edge[] {
    const connections: BrokerConnection[] = [];

    // Check if completeData exists and has required properties
    if (!completeData) {
        return [];
    }

    // Start with user inputs - they are always SOURCES (inputs only)
    if (completeData.userInputs && Array.isArray(completeData.userInputs)) {
        completeData.userInputs.forEach((userInput) => {
            if (userInput && userInput.broker_id && userInput.id) {
                const userInputConnections = traceUserInputBroker(userInput.broker_id, userInput.id, completeData);
                connections.push(...userInputConnections);
            }
        });
    }

    // Trace from relay outputs to find subsequent connections
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((relay) => {
            if (relay && relay.id && relay.target_broker_ids && Array.isArray(relay.target_broker_ids)) {
                relay.target_broker_ids.forEach((targetBrokerId) => {
                    if (targetBrokerId) {
                        const relayOutputConnections = traceRelayOutputBroker(targetBrokerId, relay.id, completeData);
                        connections.push(...relayOutputConnections);
                    }
                });
            }
        });
    }

    // Trace from workflow node return brokers to find subsequent connections
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            if (!node || !node.id) return;

            if (node.return_broker_overrides && Array.isArray(node.return_broker_overrides)) {
                node.return_broker_overrides.forEach((returnBrokerId) => {
                    if (returnBrokerId) {
                        const returnBrokerConnections = traceReturnBroker(returnBrokerId, node.id, completeData);
                        connections.push(...returnBrokerConnections);
                    }
                });
            }

            // NEW: Trace from known runtime brokers generated by this node
            try {
                const knownBrokers = getAllKnownBrokers(node as any); // TODO: Fix DbFunctionNode to FunctionNode conversion
                if (knownBrokers && Array.isArray(knownBrokers)) {
                    knownBrokers.forEach((knownBroker) => {
                        if (knownBroker && knownBroker.id) {
                            // Only trace brokers that this node generates (not global or consumed brokers)
                            if (knownBroker.id.includes(node.id) || isNodeGeneratedBroker(knownBroker.id, node)) {
                                const knownBrokerConnections = traceKnownBroker(knownBroker.id, node.id, completeData, knownBroker);
                                connections.push(...knownBrokerConnections);
                            }
                        }
                    });
                }
            } catch (error) {
                // Silently continue if getAllKnownBrokers fails
                console.warn('Failed to get known brokers for node:', node.id, error);
            }
        });
    }

    // Also trace from dependency target brokers (internal relays) to find subsequent connections
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            if (!node || !node.id) return;

            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.target_broker_id && dependency.target_broker_id.trim() !== "") {
                        const dependencyTargetConnections = traceDependencyTarget(dependency.target_broker_id, node.id, completeData);
                        connections.push(...dependencyTargetConnections);
                    }
                });
            }
        });
    }

    // Deduplicate connections before converting to edges
    const uniqueConnections = connections.filter((connection, index, self) => {
        return (
            self.findIndex(
                (c) =>
                    c.sourceNodeId === connection.sourceNodeId &&
                    c.targetNodeId === connection.targetNodeId &&
                    c.connectionType === connection.connectionType &&
                    c.sourceBrokerId === connection.sourceBrokerId
            ) === index
        );
    });

    // Convert broker connections to virtual edges
    const virtualEdges = uniqueConnections.map((connection, index) => createVirtualEdge(connection, index));

    // Convert database edges to basic edges
    const basicEdges = completeData.edges && Array.isArray(completeData.edges) 
        ? completeData.edges.filter(edge => edge).map((edge) => createBasicEdge(edge))
        : [];

    // Combine and return all edges
    return [...basicEdges, ...virtualEdges];
}

/**
 * Helper function to determine if a broker ID is generated by a specific node
 * This handles patterns like recipe_id based brokers
 */
function isNodeGeneratedBroker(brokerId: string, node: any): boolean {
    if (!node || !brokerId || typeof brokerId !== "string") {
        return false;
    }

    // For recipe nodes, check if broker ID starts with the recipe_id
    if (node.arg_overrides && Array.isArray(node.arg_overrides)) {
        const recipeIdArg = node.arg_overrides.find((arg) => arg && arg.name === "recipe_id");
        if (recipeIdArg && recipeIdArg.default_value) {
            const recipeId = recipeIdArg.default_value as string;
            if (brokerId.startsWith(recipeId + "_")) {
                return true;
            }
        }
    }
    // Add more patterns here for other node types
    // For example, if you have nodes that generate brokers based on their ID:
    // if (brokerId.startsWith(node.id + "_")) return true;

    return false;
}

/**
 * NEW: Traces where a known broker can go
 * Similar to other trace functions but includes known broker metadata
 */
function traceKnownBroker(brokerId: string, sourceNodeId: string, completeData: any, knownBroker: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!completeData || !brokerId || !sourceNodeId) {
        return connections;
    }

    // Check if this known broker goes to any relays
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((relay) => {
            if (relay && relay.id && relay.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: relay.id,
                    connectionType: "to_relay",
                    metadata: {
                        relayLabel: relay.label || undefined,
                        knownBrokerLabel: knownBroker?.label,
                        knownBrokerDescription: knownBroker?.description,
                    },
                });
            }
        });
    }

    // Check if this known broker goes to any workflow nodes
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            // Skip the same node (can't connect to itself)
            if (!node || !node.id || node.id === sourceNodeId) return;

            // Check if it's used as a dependency
            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_dependency",
                            metadata: {
                                dependencyHasTarget: !!dependency.target_broker_id,
                                knownBrokerLabel: knownBroker?.label,
                                knownBrokerDescription: knownBroker?.description,
                            },
                        });
                    }
                });
            }

            // Check if it's used as an argument
            if (node.arg_mapping && Array.isArray(node.arg_mapping)) {
                node.arg_mapping.forEach((mapping) => {
                    if (mapping && mapping.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_argument",
                            metadata: {
                                targetArgName: mapping.target_arg_name,
                                knownBrokerLabel: knownBroker?.label,
                                knownBrokerDescription: knownBroker?.description,
                            },
                        });
                    }
                });
            }
        });
    }

    return connections;
}

/**
 * Traces where a user input broker_id can go
 * Following the exact logic you described:
 * Option A: To a relay
 * Option B1: To a workflow node as a dependency
 * Option B2: To a workflow node as an argument (most common)
 */
function traceUserInputBroker(brokerId: string, sourceNodeId: string, completeData: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!completeData || !brokerId || !sourceNodeId) {
        return connections;
    }

    // Option A: Check if this broker goes to any relays
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((relay) => {
            if (relay && relay.id && relay.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: relay.id,
                    connectionType: "to_relay",
                    metadata: {
                        relayLabel: relay.label || undefined,
                    },
                });
                // TODO: Next step would be to follow each relay.target_broker_ids
                // but let's start with just identifying the immediate connection
            }
        });
    }

    // Option B: Check if this broker goes to any workflow nodes
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            if (!node || !node.id) return;

            // Option B1: Check if it's used as a dependency
            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_dependency",
                            metadata: {
                                dependencyHasTarget: !!dependency.target_broker_id,
                            },
                        });
                        // TODO: If dependency.target_broker_id exists, we need to follow that too
                    }
                });
            }

            // Option B2: Check if it's used as an argument (most common)
            if (node.arg_mapping && Array.isArray(node.arg_mapping)) {
                node.arg_mapping.forEach((mapping) => {
                    if (mapping && mapping.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_argument",
                            metadata: {
                                targetArgName: mapping.target_arg_name,
                            },
                        });
                    }
                });
            }
        });
    }

    return connections;
}

/**
 * Traces where a relay output broker_id can go
 * Similar to traceUserInputBroker but for relay target broker IDs
 */
function traceRelayOutputBroker(brokerId: string, sourceNodeId: string, completeData: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!completeData || !brokerId || !sourceNodeId) {
        return connections;
    }

    // Check if this relay output broker goes to any workflow nodes
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            if (!node || !node.id) return;

            // Check if it's used as a dependency
            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_dependency",
                            metadata: {
                                dependencyHasTarget: !!dependency.target_broker_id,
                            },
                        });
                    }
                });
            }

            // Check if it's used as an argument (most common case)
            if (node.arg_mapping && Array.isArray(node.arg_mapping)) {
                node.arg_mapping.forEach((mapping) => {
                    if (mapping && mapping.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_argument",
                            metadata: {
                                targetArgName: mapping.target_arg_name,
                            },
                        });
                    }
                });
            }
        });
    }

    // Check if this relay output goes to other relays (relay chains)
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((targetRelay) => {
            if (targetRelay && targetRelay.id && targetRelay.source_broker_id === brokerId && targetRelay.id !== sourceNodeId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: targetRelay.id,
                    connectionType: "to_relay",
                    metadata: {
                        relayLabel: targetRelay.label || undefined,
                    },
                });
            }
        });
    }

    return connections;
}

/**
 * Traces where a workflow node return broker can go
 * Return brokers can connect to:
 * 1. Relays (as source_broker_id)
 * 2. Other nodes' arg_mapping
 * 3. Other nodes' dependencies
 */
function traceReturnBroker(brokerId: string, sourceNodeId: string, completeData: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!completeData || !brokerId || !sourceNodeId) {
        return connections;
    }

    // Check if this return broker goes to any relays
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((relay) => {
            if (relay && relay.id && relay.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: relay.id,
                    connectionType: "to_relay",
                    metadata: {
                        relayLabel: relay.label || undefined,
                    },
                });
            }
        });
    }

    // Check if this return broker goes to any workflow nodes
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            // Skip the same node (can't connect to itself)
            if (!node || !node.id || node.id === sourceNodeId) return;

            // Check if it's used as a dependency
            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_dependency",
                            metadata: {
                                dependencyHasTarget: !!dependency.target_broker_id,
                            },
                        });
                    }
                });
            }

            // Check if it's used as an argument
            if (node.arg_mapping && Array.isArray(node.arg_mapping)) {
                node.arg_mapping.forEach((mapping) => {
                    if (mapping && mapping.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_argument",
                            metadata: {
                                targetArgName: mapping.target_arg_name,
                            },
                        });
                    }
                });
            }
        });
    }

    return connections;
}

/**
 * Traces where a dependency target broker can go
 * Dependency targets act like internal relays - they receive data from the source
 * and can then distribute it to other consumers
 */
function traceDependencyTarget(brokerId: string, sourceNodeId: string, completeData: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!brokerId || typeof brokerId !== "string" || brokerId.trim() === "") {
        return connections;
    }

    // Check if this dependency target goes to any relays (as source_broker_id)
    if (completeData.relays && Array.isArray(completeData.relays)) {
        completeData.relays.forEach((relay) => {
            if (relay && relay.id && relay.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: relay.id,
                    connectionType: "to_relay",
                    metadata: {
                        relayLabel: relay.label || undefined,
                    },
                });
            }
        });
    }

    // Check if this dependency target goes to any workflow nodes
    if (completeData.nodes && Array.isArray(completeData.nodes)) {
        completeData.nodes.forEach((node) => {
            // Skip the same node (can't connect to itself)
            if (!node || !node.id || node.id === sourceNodeId) return;

            // Check if it's used as a dependency source
            if (node.additional_dependencies && Array.isArray(node.additional_dependencies)) {
                node.additional_dependencies.forEach((dependency) => {
                    if (dependency && dependency.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_dependency",
                            metadata: {
                                dependencyHasTarget: !!dependency.target_broker_id,
                            },
                        });
                    }
                });
            }

            // Check if it's used as an argument source
            if (node.arg_mapping && Array.isArray(node.arg_mapping)) {
                node.arg_mapping.forEach((mapping) => {
                    if (mapping && mapping.source_broker_id === brokerId) {
                        connections.push({
                            sourceBrokerId: brokerId,
                            sourceNodeId: sourceNodeId,
                            targetNodeId: node.id,
                            connectionType: "to_argument",
                            metadata: {
                                targetArgName: mapping.target_arg_name,
                            },
                        });
                    }
                });
            }
        });
    }

    // Check if this dependency target could theoretically go to user inputs
    // (This would set the default value for the user input)
    if (completeData.userInputs && Array.isArray(completeData.userInputs)) {
        completeData.userInputs.forEach((userInput) => {
            if (userInput && userInput.id && userInput.broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: userInput.id,
                    connectionType: "to_argument", // Treat as argument since it's setting a value
                    metadata: {
                        targetArgName: "default_value",
                    },
                });
            }
        });
    }

    return connections;
}

function createBasicEdge(dbEdge: any): Edge {
    return {
        id: dbEdge.id,
        source: dbEdge.source_node_id,
        target: dbEdge.target_node_id,
        sourceHandle: dbEdge.source_handle || "output",
        targetHandle: dbEdge.target_handle || "input",
        type: dbEdge.edge_type || "default",
        animated: dbEdge.animated || false,
        style: dbEdge.style || {
            stroke: "#6b7280", // Gray color for basic edges
            strokeWidth: 2,
        },
        data: dbEdge.data || {
            connectionType: "basic",
            sourceBrokerId: "",
            label: "",
        },
    };
}

/**
 * Creates a ReactFlow Edge from a broker connection
 */
function createVirtualEdge(connection: BrokerConnection, index: number): Edge {
    // Create a deterministic ID for deduplication
    const edgeId = `virtual_${connection.sourceNodeId}_${connection.targetNodeId}_${connection.connectionType}_${connection.sourceBrokerId}`;

    // Style edges differently based on connection type
    const edgeStyles = {
        to_argument: {
            stroke: "#10b981",
            strokeWidth: 2,
            strokeDasharray: "5,5",
        },
        to_relay: {
            stroke: "#3b82f6",
            strokeWidth: 2,
        },
        to_dependency: {
            stroke: "#8b5cf6", // Purple - suggests connection/relationship
            strokeWidth: 1,
            strokeDasharray: "2,2",
        },
    };

    // Create appropriate label based on connection type and known broker info
    let label = "";
    switch (connection.connectionType) {
        case "to_argument":
            if (connection.metadata?.knownBrokerLabel) {
                label = connection.metadata.knownBrokerLabel;
            } else {
                label = connection.metadata?.targetArgName ? toTitleCase(connection.metadata.targetArgName) : "Argument";
            }
            break;
        case "to_relay":
            label = connection.metadata?.relayLabel || connection.metadata?.knownBrokerLabel || "Relay";
            break;
        case "to_dependency":
            label = connection.metadata?.knownBrokerLabel || "Dependency";
            break;
    }

    return {
        id: edgeId,
        source: connection.sourceNodeId,
        target: connection.targetNodeId,
        sourceHandle: "output", // Default output handle for source node
        targetHandle: "input", // Default input handle for target node
        type: "default", // Use our custom edge type
        animated: connection.connectionType === "to_dependency",
        style: edgeStyles[connection.connectionType],
        data: {
            connectionType: connection.connectionType,
            sourceBrokerId: connection.sourceBrokerId,
            targetArgName: connection.metadata?.targetArgName,
            relayLabel: connection.metadata?.relayLabel,
            dependencyHasTarget: connection.metadata?.dependencyHasTarget,
            knownBrokerLabel: connection.metadata?.knownBrokerLabel,
            knownBrokerDescription: connection.metadata?.knownBrokerDescription,
            isKnownBroker: !!connection.metadata?.knownBrokerLabel, // Flag to indicate this uses known broker info
            label: label, // Move label to metadata for custom rendering
        },
    };
}
