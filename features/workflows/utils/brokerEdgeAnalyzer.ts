import { ConvertedWorkflowData, FunctionNode } from "../types";
import { getAllKnownBrokers } from "./knownBrokersRegistry";

// Local type definitions - only what we need
export interface Edge {
    id: string;
    source: string;
    target: string;
    sourceHandle?: string;
    targetHandle?: string;
    type?: string;
    animated?: boolean;
    isVirtual: boolean; // Direct flag to identify virtual vs database edges
    style?: {
        stroke?: string;
        strokeWidth?: number;
        strokeDasharray?: string;
    };
    data?: {
        connectionType: string;
        sourceBrokerId: string;
        metadata: {
            targetArgName?: string;
            relayLabel?: string;
            dependencyHasTarget?: boolean;
            knownBrokerLabel?: string;
            knownBrokerDescription?: string;
            isKnownBroker?: boolean;
        };
        label: string;
    };
}

interface UserInput {
    id: string;
    broker_id: string;
}

interface Relay {
    id: string;
    source_broker_id?: string;
    target_broker_ids?: string[];
    label?: string;
}

interface ArgMapping {
    source_broker_id: string;
    target_arg_name: string;
}

interface Dependency {
    source_broker_id: string;
    target_broker_id?: string;
}

interface ArgOverride {
    name: string;
    default_value?: unknown;
}

interface WorkflowNode {
    id: string;
    return_broker_overrides?: string[];
    additional_dependencies?: Dependency[];
    arg_mapping?: ArgMapping[];
    arg_overrides?: ArgOverride[];
}

interface DatabaseEdge {
    id: string;
    source_node_id: string;
    target_node_id: string;
}


function toTitleCase(snakeCase: string): string {
    if (!snakeCase || typeof snakeCase !== "string") {
        return snakeCase || "";
    }
    return snakeCase
        .split("_")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join(" ");
}

interface BrokerConnection {
    sourceBrokerId: string;
    sourceNodeId: string;
    targetNodeId: string;
    connectionType: "to_argument" | "to_relay" | "to_dependency";
    metadata?: {
        targetArgName?: string; // For argument connections
        relayLabel?: string; // For relay connections
        dependencyHasTarget?: boolean; // For dependency connections
        knownBrokerLabel?: string; // Label from known brokers registry
        knownBrokerDescription?: string; // Description from known brokers registry
    };
}

/**
 * Enhanced broker connection analyzer that considers known brokers
 * Starting with user inputs and now including runtime-generated brokers
 * Also processes basic database edges alongside virtual broker connections
 */
export function analyzeBrokerConnections(completeData: ConvertedWorkflowData): Edge[] {
    const connections: BrokerConnection[] = [];

    // Start with user inputs - they are always SOURCES (inputs only)
    completeData.userInputs.forEach((userInput) => {
        const userInputConnections = traceUserInputBroker(userInput.data.broker_id, userInput.id, completeData);
        connections.push(...userInputConnections);
    });

    // Trace from relay outputs to find subsequent connections
    completeData.relays.forEach((relay) => {
        relay.data.target_broker_ids?.forEach((targetBrokerId) => {
            const relayOutputConnections = traceRelayOutputBroker(targetBrokerId, relay.id, completeData);
            connections.push(...relayOutputConnections);
        });
    });

    // Trace from workflow node return brokers to find subsequent connections
    completeData.functionNodes.forEach((node) => {
        node.data.return_broker_overrides?.forEach((returnBrokerId) => {
            const returnBrokerConnections = traceReturnBroker(returnBrokerId, node.id, completeData);
            connections.push(...returnBrokerConnections);
        });

        // NEW: Trace from known runtime brokers generated by this node
        const knownBrokers = getAllKnownBrokers(node);
        knownBrokers.forEach((knownBroker) => {
            // Only trace brokers that this node generates (not global or consumed brokers)
            if (knownBroker.id.includes(node.id) || isNodeGeneratedBroker(knownBroker.id, node)) {
                const knownBrokerConnections = traceKnownBroker(knownBroker.id, node.id, completeData, knownBroker);
                connections.push(...knownBrokerConnections);
            }
        });
    });

    // Also trace from dependency target brokers (internal relays) to find subsequent connections
    completeData.functionNodes.forEach((node) => {
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.target_broker_id && dependency.target_broker_id.trim() !== "") {
                const dependencyTargetConnections = traceDependencyTarget(dependency.target_broker_id, node.id, completeData);
                connections.push(...dependencyTargetConnections);
            }
        });
    });

    // Deduplicate connections before converting to edges
    const uniqueConnections = connections.filter((connection, index, self) => {
        return (
            self.findIndex(
                (c) =>
            c.sourceNodeId === connection.sourceNodeId &&
            c.targetNodeId === connection.targetNodeId &&
            c.connectionType === connection.connectionType &&
            c.sourceBrokerId === connection.sourceBrokerId
        ) === index
        );
    });

    // Convert broker connections to virtual edges
    const virtualEdges = uniqueConnections.map((connection, index) => createVirtualEdge(connection, index));

    // Convert database edges to basic edges
    const basicEdges = completeData.edges.map((edge) => createBasicEdge(edge as any)); // TODO: Fix WorkflowEdge to Edge conversion

    // Combine and return all edges
    return [...basicEdges, ...virtualEdges];
}

/**
 * Helper function to determine if a broker ID is generated by a specific node
 * This handles patterns like recipe_id based brokers
 */
function isNodeGeneratedBroker(brokerId: string, node: WorkflowNode): boolean {
    // For recipe nodes, check if broker ID starts with the recipe_id
    const recipeIdArg = node.arg_overrides?.find((arg) => arg.name === "recipe_id");
    if (recipeIdArg?.default_value) {
        const recipeId = recipeIdArg.default_value as string;
        if (brokerId.startsWith(recipeId + "_")) {
            return true;
        }
    }
    // Add more patterns here for other node types
    // For example, if you have nodes that generate brokers based on their ID:
    // if (brokerId.startsWith(node.id + "_")) return true;

    return false;
}

/**
 * NEW: Traces where a known broker can go
 * Similar to other trace functions but includes known broker metadata
 */
function traceKnownBroker(brokerId: string, sourceNodeId: string, completeData: ConvertedWorkflowData, knownBroker: any): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    // Check if this known broker goes to any relays
    completeData.relays.forEach((relay) => {
        if (relay.data.source_broker_id === brokerId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: relay.id,
                connectionType: "to_relay",
                metadata: {
                    relayLabel: relay.data.label || undefined,
                    knownBrokerLabel: knownBroker.label,
                    knownBrokerDescription: knownBroker.description,
                },
            });
        }
    });

    // Check if this known broker goes to any workflow nodes
    completeData.functionNodes.forEach((node) => {
        // Skip the same node (can't connect to itself)
        if (node.id === sourceNodeId) return;

        // Check if it's used as a dependency
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_dependency",
                    metadata: {
                        dependencyHasTarget: !!dependency.target_broker_id,
                        knownBrokerLabel: knownBroker.label,
                        knownBrokerDescription: knownBroker.description,
                    },
                });
            }
        });

        // Check if it's used as an argument
        node.data.arg_mapping?.forEach((mapping) => {
            if (mapping.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_argument",
                    metadata: {
                        targetArgName: mapping.target_arg_name,
                        knownBrokerLabel: knownBroker.label,
                        knownBrokerDescription: knownBroker.description,
                    },
                });
            }
        });
    });

    return connections;
}

/**
 * Traces where a user input broker_id can go
 * Following the exact logic you described:
 * Option A: To a relay
 * Option B1: To a workflow node as a dependency
 * Option B2: To a workflow node as an argument (most common)
 */
function traceUserInputBroker(brokerId: string, sourceNodeId: string, completeData: ConvertedWorkflowData): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    // Option A: Check if this broker goes to any relays
    completeData.relays.forEach((relay) => {
        if (relay.data.source_broker_id === brokerId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: relay.id,
                connectionType: "to_relay",
                metadata: {
                    relayLabel: relay.data.label || undefined,
                },
            });
            // TODO: Next step would be to follow each relay.target_broker_ids
            // but let's start with just identifying the immediate connection
        }
    });

    // Option B: Check if this broker goes to any workflow nodes
    completeData.functionNodes.forEach((node) => {
        // Option B1: Check if it's used as a dependency
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_dependency",
                    metadata: {
                        dependencyHasTarget: !!dependency.target_broker_id,
                    },
                });
                // TODO: If dependency.target_broker_id exists, we need to follow that too
            }
        });

        // Option B2: Check if it's used as an argument (most common)
        node.data.arg_mapping?.forEach((mapping) => {
            if (mapping.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_argument",
                    metadata: {
                        targetArgName: mapping.target_arg_name,
                    },
                });
            }
        });
    });

    return connections;
}

/**
 * Traces where a relay output broker_id can go
 * Similar to traceUserInputBroker but for relay target broker IDs
 */
function traceRelayOutputBroker(brokerId: string, sourceNodeId: string, completeData: ConvertedWorkflowData): BrokerConnection[] {
    const connections: BrokerConnection[] = [];
   
    // Check if this relay output broker goes to any workflow nodes
    completeData.functionNodes.forEach((node) => {
        // Check if it's used as a dependency
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_dependency",
                    metadata: {
                        dependencyHasTarget: !!dependency.target_broker_id,
                    },
                });
            }
        });

        // Check if it's used as an argument (most common case)
        node.data.arg_mapping?.forEach((mapping) => {
            if (mapping.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_argument",
                    metadata: {
                        targetArgName: mapping.target_arg_name,
                    },
                });
            }
        });
    });

    // Check if this relay output goes to other relays (relay chains)
    completeData.relays.forEach((targetRelay) => {
        if (targetRelay.data.source_broker_id === brokerId && targetRelay.id !== sourceNodeId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: targetRelay.id,
                connectionType: "to_relay",
                metadata: {
                    relayLabel: targetRelay.data.label || undefined,
                },
            });
        }
    });

    return connections;
}

/**
 * Traces where a workflow node return broker can go
 * Return brokers can connect to:
 * 1. Relays (as source_broker_id)
 * 2. Other nodes' arg_mapping
 * 3. Other nodes' dependencies
 */
function traceReturnBroker(brokerId: string, sourceNodeId: string, completeData: ConvertedWorkflowData): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    // Check if this return broker goes to any relays
    completeData.relays.forEach((relay) => {
        if (relay.data.source_broker_id === brokerId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: relay.id,
                connectionType: "to_relay",
                metadata: {
                    relayLabel: relay.data.label || undefined,
                },
            });
        }
    });

    // Check if this return broker goes to any workflow nodes
    completeData.functionNodes.forEach((node) => {
        // Skip the same node (can't connect to itself)
        if (node.id === sourceNodeId) return;

        // Check if it's used as a dependency
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_dependency",
                    metadata: {
                        dependencyHasTarget: !!dependency.target_broker_id,
                    },
                });
            }
        });

        // Check if it's used as an argument
        node.data.arg_mapping?.forEach((mapping) => {
            if (mapping.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_argument",
                    metadata: {
                        targetArgName: mapping.target_arg_name,
                    },
                });
            }
        });
    });

    return connections;
}

/**
 * Traces where a dependency target broker can go
 * Dependency targets act like internal relays - they receive data from the source
 * and can then distribute it to other consumers
 */
function traceDependencyTarget(brokerId: string, sourceNodeId: string, completeData: ConvertedWorkflowData): BrokerConnection[] {
    const connections: BrokerConnection[] = [];

    if (!brokerId || typeof brokerId !== "string" || brokerId.trim() === "") {
        return connections;
    }

    // Check if this dependency target goes to any relays (as source_broker_id)
    completeData.relays.forEach((relay) => {
        if (relay.data.source_broker_id === brokerId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: relay.id,
                connectionType: "to_relay",
                metadata: {
                    relayLabel: relay.data.label || undefined,
                },
            });
        }
    });

    // Check if this dependency target goes to any workflow nodes
    completeData.functionNodes.forEach((node) => {
        // Skip the same node (can't connect to itself)
        if (node.id === sourceNodeId) return;

        // Check if it's used as a dependency source
        node.data.additional_dependencies?.forEach((dependency) => {
            if (dependency.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_dependency",
                    metadata: {
                        dependencyHasTarget: !!dependency.target_broker_id,
                    },
                });
            }
        });

        // Check if it's used as an argument source
        node.data.arg_mapping?.forEach((mapping) => {
            if (mapping.source_broker_id === brokerId) {
                connections.push({
                    sourceBrokerId: brokerId,
                    sourceNodeId: sourceNodeId,
                    targetNodeId: node.id,
                    connectionType: "to_argument",
                    metadata: {
                        targetArgName: mapping.target_arg_name,
                    },
                });
            }
        });
    });

    // Check if this dependency target could theoretically go to user inputs
    // (This would set the default value for the user input)
    completeData.userInputs.forEach((userInput) => {
        if (userInput.data.broker_id === brokerId) {
            connections.push({
                sourceBrokerId: brokerId,
                sourceNodeId: sourceNodeId,
                targetNodeId: userInput.id,
                connectionType: "to_argument", // Treat as argument since it's setting a value
                metadata: {
                    targetArgName: "default_value",
                },
            });
        }
    });

    return connections;
}

/**
 * Creates a basic ReactFlow Edge from a database edge
 */
function createBasicEdge(dbEdge: Edge): Edge {
    return {
        id: dbEdge.id,
        source: dbEdge.source,
        target: dbEdge.target,
        sourceHandle: "output",
        targetHandle: "input",
        type: "default", // Use default edge type for basic edges
        isVirtual: false, // Database edges are NOT virtual
        style: {
            stroke: "#6b7280", // Gray color for basic edges
            strokeWidth: 2,
        },
        data: {
            connectionType: "basic",
            sourceBrokerId: "", // No broker for basic edges
            metadata: {},
            label: "", // No label for basic edges
        },
    };
}

/**
 * Creates a ReactFlow Edge from a broker connection
 */
function createVirtualEdge(connection: BrokerConnection, index: number): Edge {
    // Create a deterministic ID for deduplication
    const edgeId = `virtual_${connection.sourceNodeId}_${connection.targetNodeId}_${connection.connectionType}_${connection.sourceBrokerId}`;

    // Style edges differently based on connection type
    const edgeStyles = {
        to_argument: {
            stroke: "#10b981",
            strokeWidth: 2,
            strokeDasharray: "5,5",
        },
        to_relay: {
            stroke: "#3b82f6",
            strokeWidth: 2,
        },
        to_dependency: {
            stroke: "#8b5cf6", // Purple - suggests connection/relationship
            strokeWidth: 1,
            strokeDasharray: "2,2",
        },
    };

    // Create appropriate label based on connection type and known broker info
    let label = "";
    switch (connection.connectionType) {
        case "to_argument":
            if (connection.metadata?.knownBrokerLabel) {
                label = connection.metadata.knownBrokerLabel;
            } else {
                label = connection.metadata?.targetArgName ? toTitleCase(connection.metadata.targetArgName) : "Argument";
            }
            break;
        case "to_relay":
            label = connection.metadata?.relayLabel || connection.metadata?.knownBrokerLabel || "Relay";
            break;
        case "to_dependency":
            label = connection.metadata?.knownBrokerLabel || "Dependency";
            break;
    }

    return {
        id: edgeId,
        source: connection.sourceNodeId,
        target: connection.targetNodeId,
        sourceHandle: "output", // Default output handle for source node
        targetHandle: "input", // Default input handle for target node
        type: "custom", // Use our custom edge type
        animated: connection.connectionType === "to_dependency",
        isVirtual: true, // Virtual edges are created from broker connections
        style: edgeStyles[connection.connectionType],
        data: {
            connectionType: connection.connectionType,
            sourceBrokerId: connection.sourceBrokerId,
            metadata: {
                ...connection.metadata,
                isKnownBroker: !!connection.metadata?.knownBrokerLabel, // Flag to indicate this uses known broker info
            },
            label: label, // Move label to data for custom rendering
        },
    };
}