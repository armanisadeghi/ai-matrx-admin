---
description: Autonomous feedback resolution workflow - use when handling user feedback, bug reports, or feature requests from the feedback system
alwaysApply: false
---

# Feedback Resolution System

All feedback state lives in the database. The admin UI at `/administration/feedback` is the source of truth.

## Permissions & Status Flow

| Status | Set By | Method |
|--------|--------|--------|
| `new` | System | User submits feedback |
| `triaged` | Agent | `triage_feedback_item()` |
| `split` | Agent | `split_feedback_item()` — parent replaced by sub-tasks |
| `in_progress` | System | Auto-set when agent picks up approved item |
| `awaiting_review` | Agent | `resolve_with_testing()` — **agent's terminal status** |
| `resolved` | Admin only | After testing passes |
| `closed` | Admin only | User confirmed or admin closes |
| `wont_fix` | Admin only | Admin declines |
| `deferred` | Admin only | Admin postpones |

`awaiting_review` is where the agent's involvement ends. After calling `resolve_with_testing()`, do not touch the item again unless the admin rejects it back to `in_progress`.

A database trigger prevents setting `closed`/`resolved` without a `testing_result`. Always use `resolve_with_testing()` to finish a fix.

## Session Workflow

Each session, pull two lists:

```sql
SELECT * FROM get_untriaged_feedback();
SELECT * FROM get_agent_work_queue();
```

Rework items (failed/partial tests) appear in the work queue and take priority over new work.

### Step 1: Triage Untriaged Items

For each item from `get_untriaged_feedback()`:

**A. View screenshots FIRST (mandatory if `image_urls` is not null)**

Fetch signed URLs via `GET /api/admin/feedback/images?feedback_id=<uuid>`, open every one, and study them. Screenshots are the most reliable source of truth — they show exactly what the user saw. Skipping this step has caused agents to misidentify the component and fix the wrong thing entirely.

**B. Read the item fields** — `description`, `feedback_type`, `username`, `route`

> **`route` is NOT the bug location.** It records where the user was when they clicked "Submit Feedback" — nothing more. The actual bug could be in a shared layout, header, sidebar, global provider, toast system, or modal. Always determine the real location from description + screenshots + code research.

**C. Check for admin early-feedback**
- Read `admin_notes` and comments (`get_feedback_comments`)
- If the admin provided direction or context, factor it in

**D. Research the relevant code** and confirm the root cause matches what screenshots show.

**E. Compute autonomy score (1–5)** — +1 for each true statement:

| Factor |
|--------|
| Requested by `arman@armansadeghi.com` (lead developer) |
| Clearly a bug — app is objectively broken |
| Not opinion-based — the fix is objectively correct |
| Zero risk of negative side effects |
| Simple fix — CSS, typo, config, single-file change |

**F. Decide: triage normally or split**

If the item is `complex` and involves 2+ genuinely independent changes, consider splitting (see Step 1b below). Otherwise, triage normally:

```sql
SELECT * FROM triage_feedback_item(
  '<id>'::uuid,
  'Proposed approach',              -- p_ai_solution_proposal
  'high',                           -- p_ai_suggested_priority
  'moderate',                       -- p_ai_complexity
  ARRAY['path/to/file.tsx'],        -- p_ai_estimated_files
  4,                                -- p_autonomy_score
  'Detailed assessment'             -- p_ai_assessment
);
```

**G. Auto-approve if score is 4–5:**

```sql
SELECT * FROM set_admin_decision('<id>'::uuid, 'approved', NULL, <next_priority>);
SELECT * FROM add_feedback_comment('<id>'::uuid, 'ai_agent', 'AI Agent',
  'Auto-approved: autonomy score 5/5. Clear bug, safe fix, no side effects.');
```

For scores 2–3, wait for admin decision. For 0–1, add a comment flagging concerns.

### Step 1b: Splitting Complex Items

During triage, you may determine that an item should be broken into independent sub-tasks rather than handled as one unit.

**When to split:**
- Complexity is `complex` and involves 2+ genuinely independent changes
- Sub-tasks touch different components/subsystems with no shared dependencies
- Each sub-task is independently testable
- Splitting gives the admin clearer, focused test instructions per sub-task

**When NOT to split:**
- Changes are cohesive (one refactor touching 5 files = still 1 task)
- Sub-tasks depend on each other or must be tested together
- Total scope is manageable in a single session — would all get done together anyway

**Process:**

1. Write clear, self-contained descriptions for each sub-task
2. Call `split_feedback_item` — parent moves to `split`, children created as `new` linked via `parent_id`
3. Comment on the parent explaining the split rationale
4. Triage each child immediately (each gets its own assessment, autonomy score, auto-approve decision)

Do NOT call `triage_feedback_item` on the parent — it goes directly from `new` to `split`.

```sql
-- 1. Split parent into sub-tasks
SELECT * FROM split_feedback_item(
  '<parent_id>'::uuid,
  ARRAY[
    'Fix header dropdown z-index issue on /notes page',
    'Update sidebar nav highlight to reflect active route',
    'Fix toast notification positioning on mobile viewports'
  ]
);

-- 2. Explain the split
SELECT * FROM add_feedback_comment('<parent_id>'::uuid, 'ai_agent', 'AI Agent',
  'Split into 3 sub-tasks: header z-index, sidebar highlight, mobile toast. Independent components, no shared dependencies.');

-- 3. Triage each child (IDs returned by split_feedback_item)
SELECT * FROM triage_feedback_item('<child1>'::uuid, ...);
SELECT * FROM triage_feedback_item('<child2>'::uuid, ...);
SELECT * FROM triage_feedback_item('<child3>'::uuid, ...);
```

### Step 2: Work Through Approved Queue

For each item from `get_agent_work_queue()`:

1. Read `admin_direction` and comments for context
2. Research and implement the fix
3. Add progress comments as you work

### Step 3: Submit for Testing

```sql
SELECT * FROM resolve_with_testing(
  '<id>'::uuid,
  'What was fixed and how',
  'Step-by-step testing instructions',
  'http://localhost:3000/relevant-page'
);
```

**Testing instructions must** (admin verifies in under 60 seconds):
- Include the URL where the fix is verifiable — almost certainly NOT the `route` field
- List exact steps to reproduce/verify
- Describe "fixed" vs "broken" behavior
- Note if multiple modes need testing (dark mode, mobile, etc.)
- Re-read the description and screenshots before submitting — confirm your instructions test what the user actually reported

### Step 4: Handle Rework

When the admin rejects a fix, the item returns to `in_progress` with `testing_result` set to `fail` or `partial`. These appear in your normal work queue.

1. Read admin comments to understand what failed
2. Fix the remaining issues
3. Comment to acknowledge the failure and explain changes
4. Re-call `resolve_with_testing()` with updated notes and instructions

### Step 5: Chat Summary

After processing a batch, give a brief summary: items triaged, items fixed, items needing admin discussion, and anything skipped. Details are in the DB — don't reproduce them in chat.

## SQL Reference

```sql
-- Triage
SELECT * FROM triage_feedback_item(id, solution, priority, complexity, files[], autonomy, assessment);

-- Split into sub-tasks (parent -> 'split', children -> 'new')
SELECT * FROM split_feedback_item(parent_id, ARRAY['sub-task 1', 'sub-task 2']);

-- Approve (auto-approve for autonomy 4-5)
SELECT * FROM set_admin_decision(id, 'approved', direction, work_priority);

-- Submit fix for testing (agent's terminal action)
SELECT * FROM resolve_with_testing(id, resolution_notes, testing_instructions, testing_url);

-- Comments
SELECT * FROM add_feedback_comment(id, 'ai_agent', 'AI Agent', 'content');
SELECT * FROM get_feedback_comments(id);

-- Queries
SELECT * FROM get_untriaged_feedback();
SELECT * FROM get_agent_work_queue();
SELECT * FROM get_feedback_by_status('in_progress');
SELECT get_feedback_summary();

-- ADMIN-ONLY (never call these)
SELECT * FROM close_feedback_item(id, status, admin_notes);
```
