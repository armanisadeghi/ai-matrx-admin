---
description: Autonomous feedback resolution workflow - use when handling user feedback, bug reports, or feature requests from the feedback system
alwaysApply: false
---

# DB-First Feedback Resolution Workflow

All state lives in the database. No markdown files. No chat-based reporting. The admin UI at `/administration/feedback` is the source of truth.

## CRITICAL: Agent Boundaries — READ THIS FIRST

**Agents are NEVER permitted to mark items as "done".** The admin is the ONLY person who can move items to resolved, closed, wont_fix, or deferred status. Agents have exactly two jobs:

1. **Triage** — analyze new items and push AI assessment (`new` → `triaged`)
2. **Fix & submit for testing** — implement approved fixes and submit them for admin review (`in_progress` → `awaiting_review`)

The agent's terminal status is **`awaiting_review`**. That's it. Once you call `resolve_with_testing()`, you are DONE with that item. Walk away. The admin will test it and decide what happens next.

### Forbidden Agent Actions

| Action | Why It's Forbidden |
|--------|--------------------|
| Setting status to `resolved` | Only the admin can verify a fix works |
| Setting status to `closed` | Only the admin closes items |
| Setting status to `wont_fix` | Only the admin can decline items |
| Setting status to `deferred` | Only the admin can defer items |
| Calling `close_feedback_item()` | This is an ADMIN-ONLY function |
| Using raw SQL UPDATE on status to any "done" state | Bypasses the pipeline — admin never sees it |

### Allowed Agent Status Transitions

| From | To | How | When |
|------|----|-----|------|
| `new` | `triaged` | `triage_feedback_item()` | After analyzing the item |
| `triaged` | `in_progress` | Automatic when agent starts working (via work queue) | After admin approves |
| `in_progress` | `awaiting_review` | `resolve_with_testing()` | After implementing the fix |

That's the complete list. There are NO other status transitions an agent is allowed to make.

## Pipeline Overview

The admin UI has a pipeline view with these mutually exclusive stages:

| Stage | Who Acts | What's Here |
|-------|----------|-------------|
| **Untriaged** | Agent | `status = 'new'` — agent hasn't analyzed yet |
| **Your Decision** | Admin | `status = 'triaged'` + `admin_decision = 'pending'` — agent analyzed, admin hasn't decided |
| **Agent Working** | Agent | `admin_decision = 'approved'` + `status IN ('triaged','in_progress')` — approved, agent fixing |
| **Test Results** | Admin | `status = 'awaiting_review'` — agent fixed, admin MUST test before anything moves to Done |
| **Done** | Admin ONLY | `status IN ('resolved','closed','wont_fix','deferred')` — ONLY the admin moves items here |

**Your two lists on each session:**
- **List 1 (Untriaged):** `SELECT * FROM get_untriaged_feedback();` — items to analyze
- **List 2 (Work Queue):** `SELECT * FROM get_agent_work_queue();` — approved items to fix, in priority order

## SQL Quick Reference

All operations use the Supabase MCP `execute_sql` tool.

```sql
-- LIST 1: Get untriaged items (status='new', excludes split children, oldest first)
SELECT * FROM get_untriaged_feedback();

-- LIST 2: Get approved work queue (ordered by work_priority ASC)
SELECT * FROM get_agent_work_queue();

-- Summary counts (excludes closed from totals)
SELECT get_feedback_summary();

-- Items by specific status
SELECT * FROM get_feedback_by_status('in_progress');

-- TRIAGE: Push AI analysis (sets status → 'triaged')
SELECT * FROM triage_feedback_item(
  '<uuid>'::uuid,
  'Proposed solution approach',           -- p_ai_solution_proposal
  'high',                                  -- p_ai_suggested_priority (low/medium/high/critical)
  'moderate',                              -- p_ai_complexity (simple/moderate/complex)
  ARRAY['path/to/file1.tsx'],              -- p_ai_estimated_files
  4,                                       -- p_autonomy_score (1-5)
  'Detailed assessment of the issue'       -- p_ai_assessment
);

-- APPROVE (agent auto-approve for score 4-5): Sets decision + transitions status
SELECT * FROM set_admin_decision(
  '<uuid>'::uuid,
  'approved',                              -- p_decision
  NULL,                                    -- p_direction (optional admin instructions)
  1                                        -- p_work_priority (1 = highest)
);

-- RESOLVE: Push fix details + testing info (sets status → 'awaiting_review')
SELECT * FROM resolve_with_testing(
  '<uuid>'::uuid,
  'What was fixed and how',                -- p_resolution_notes
  'Step-by-step testing instructions',     -- p_testing_instructions
  'http://localhost:3000/page'             -- p_testing_url
);

-- COMMENT: Add a comment (for mid-work notes, explanations)
SELECT * FROM add_feedback_comment(
  '<uuid>'::uuid,
  'ai_agent',                              -- p_author_type ('user'|'admin'|'ai_agent')
  'AI Agent',                              -- p_author_name
  'Comment content here'                   -- p_content
);

-- READ COMMENTS on an item
SELECT * FROM get_feedback_comments('<uuid>'::uuid);

-- ============================================================
-- ADMIN-ONLY FUNCTIONS BELOW — AGENTS MUST NEVER CALL THESE
-- ============================================================

-- CLOSE (ADMIN ONLY — agent must NEVER call this)
SELECT * FROM close_feedback_item(
  '<uuid>'::uuid,
  'resolved',                              -- p_status ('resolved'|'closed'|'wont_fix')
  'Verified by admin'                      -- p_admin_notes
);

-- SPLIT a parent into sub-tasks (parent → 'split', children created as 'new')
SELECT * FROM split_feedback_item(
  '<parent_uuid>'::uuid,
  ARRAY['Sub-task 1 description', 'Sub-task 2 description']
);
```

## Status Lifecycle

```
AGENT transitions:
  new → triaged                    (triage_feedback_item)
  in_progress → awaiting_review    (resolve_with_testing — agent's FINAL action)

ADMIN-ONLY transitions:
  awaiting_review → resolved       (admin verified fix works)
  resolved → closed                (admin or user confirmed)
  any → wont_fix                   (admin declines)
  triaged → deferred               (admin defers)
  triaged → split                  (admin splits into sub-tasks)

SYSTEM transitions:
  triaged → in_progress            (automatic when agent picks up approved item)
```

- **new**: Submitted, agent hasn't analyzed
- **triaged**: Agent analyzed, awaiting admin decision
- **in_progress**: Admin approved, agent actively fixing
- **awaiting_review**: Fix done, **admin needs to test** — this is the agent's LAST stop
- **resolved**: **ADMIN ONLY** — admin verified fix works
- **closed**: **ADMIN ONLY** — user confirmed or auto-closed
- **wont_fix**: **ADMIN ONLY** — declined with reason
- **split**: **ADMIN ONLY** — parent broken into sub-tasks
- **deferred**: **ADMIN ONLY** — pushed to later

## Step 1: Triage Untriaged Items

```sql
SELECT * FROM get_untriaged_feedback();
```

For each item:

1. Read `description`, `feedback_type`, `username`, `image_urls`, and `route`
   - **Important:** The `route` field is where the user happened to be when they clicked "Submit Feedback" — it is NOT necessarily where the bug occurs. Users often report bugs from a different page than where they saw the issue. Treat `route` as a weak hint, not a source of truth. Always determine the actual affected route/files from the description and your own code research.
2. **Check for admin early-feedback** — the admin may have seen this item first and left context:
   - Read `admin_notes` field on the item (may contain admin's initial thoughts)
   - Check for existing comments: `SELECT * FROM get_feedback_comments('<id>'::uuid);`
   - If the admin has already provided direction or context, factor it into your analysis. This can save significant time — the admin may have already identified the root cause or pointed you to specific files.
3. If `image_urls` is not null, view screenshots:
   - `GET /api/admin/feedback/images?feedback_id=<uuid>` for signed URLs
   - Open signed URLs in browser to see the issue
4. Research relevant code to understand the problem
5. Compute **autonomy score (1-5)**:

| Factor | +1 if True |
|--------|-----------|
| Requested by `arman@armansadeghi.com` (lead developer, trusted) | Yes |
| Clearly a bug — app is objectively broken | Yes |
| Not opinion-based — the fix is objectively correct | Yes |
| Zero risk of negative side effects | Yes |
| Simple fix — CSS, typo, config, single-file change | Yes |

6. Push analysis to DB:

```sql
SELECT * FROM triage_feedback_item(
  '<id>'::uuid, 'Proposed approach: ...', 'high', 'moderate',
  ARRAY['file1.tsx', 'file2.ts'], 4, 'Assessment: ...'
);
```

This sets status to `triaged`. **Do NOT set `in_progress` during triage.**

### Auto-Approve (Score 4-5 Only)

If the autonomy score is 4 or 5, you may auto-approve immediately after triaging:

1. First triage the item (above)
2. Then approve it:
```sql
SELECT * FROM set_admin_decision('<id>'::uuid, 'approved', NULL, <next_priority>);
```
3. Add an explanatory comment:
```sql
SELECT * FROM add_feedback_comment('<id>'::uuid, 'ai_agent', 'AI Agent',
  'Auto-approved: autonomy score 5/5. Clear bug from lead dev, safe fix, no side effects.');
```
4. The item now appears in the work queue — proceed to fix it

**Score 2-3**: Triage only. Wait for admin decision via the UI.
**Score 0-1**: Triage only. Add a comment flagging concerns for admin.

## Step 2: Work Through Approved Queue

```sql
SELECT * FROM get_agent_work_queue();
```

Returns items ordered by `work_priority ASC` (1 = do first).

For each item:
1. Check `admin_direction` for specific instructions from admin
2. Check comments for additional context: `SELECT * FROM get_feedback_comments('<id>'::uuid);`
3. Research the code
4. Add progress comments as you work:
```sql
SELECT * FROM add_feedback_comment('<id>'::uuid, 'ai_agent', 'AI Agent',
  'Found root cause in components/Foo.tsx line 42. The issue is...');
```
5. Implement the fix

## Step 3: Submit for Admin Testing (Agent's FINAL Action)

**CRITICAL: `resolve_with_testing()` is the ONLY function you call when you finish a fix.** This sets status to `awaiting_review` — NOT `resolved`. The admin will test your fix and decide whether it passes or fails. You are DONE with the item after this call.

**What happens after you call `resolve_with_testing()`:**
- The item moves to the **Test Results** pipeline stage
- The admin sees your testing instructions and clickable URL
- The admin tests and either approves (→ resolved) or rejects (→ back to in_progress)
- **You do NOT touch the item again** unless the admin rejects it and sends it back

```sql
SELECT * FROM resolve_with_testing(
  '<id>'::uuid,
  'Fixed the padding issue by adding pb-32 to NoteEditor.tsx content container',
  '1. Go to http://localhost:3000/notes\n2. Open any note with lots of content\n3. Scroll to the bottom\n4. Verify generous padding below last line\n5. Test in both plain text and preview modes',
  'http://localhost:3000/notes'
);
```

### What You Must NEVER Do After Fixing

- **NEVER** call `close_feedback_item()` — that's admin-only
- **NEVER** set status to `resolved`, `closed`, or `wont_fix` via any method
- **NEVER** use raw SQL `UPDATE user_feedback SET status = 'resolved'` or any "done" status
- **NEVER** skip `resolve_with_testing()` by updating status directly — the admin needs testing instructions

Your job ends at `awaiting_review`. Period.

### Testing Instructions Quality

Testing instructions must be specific enough that the admin can verify in under 60 seconds:
- Include the exact URL/route **where the fix can be verified** — this may differ from the `route` field on the item (which is just where the user was when they submitted, not necessarily where the bug is)
- List exact steps to reproduce or verify
- Describe what "fixed" looks like vs what "broken" looked like
- Mention if multiple modes need testing (dark mode, mobile, etc.)

## Step 4: Brief Chat Summary

After processing a batch, give a **brief** summary in chat:

- How many items triaged
- How many items fixed
- Any items needing admin discussion (low autonomy)
- Any items skipped and why

**Do NOT reproduce testing checklists or resolution notes in chat** — they're in the DB. The admin reviews everything via the pipeline UI at `/administration/feedback`.

## Step 5: Handle Failed Tests

After the admin tests items, check for items that moved back:

```sql
SELECT * FROM get_feedback_by_status('in_progress');
```

If an item was previously `awaiting_review` and is now `in_progress`, the admin rejected the fix. Check comments for their feedback:

```sql
SELECT * FROM get_feedback_comments('<id>'::uuid);
```

Fix the issue and resolve again.

## Database Schema Reference

**Table: `user_feedback`**

| Column | Type | Notes |
|--------|------|-------|
| id | uuid | PK |
| user_id | uuid | FK to auth.users |
| username | text | Email or display name |
| feedback_type | text | bug, feature, suggestion, other |
| route | text | Page user was on when submitting (NOT necessarily where the bug is) |
| description | text | User's description |
| status | text | new, triaged, in_progress, awaiting_review, resolved, closed, wont_fix, split, deferred |
| priority | text | low, medium, high, critical |
| parent_id | uuid | FK self — for split sub-tasks |
| admin_notes | text | Internal notes |
| admin_direction | text | Admin's specific instructions for agent (read this before working) |
| admin_decision | text | pending, approved, rejected, deferred, split |
| work_priority | integer | Sort order (1 = do first) |
| ai_assessment | text | Agent's analysis of the issue |
| ai_solution_proposal | text | Agent's proposed approach |
| ai_suggested_priority | text | Agent's recommended priority |
| ai_complexity | text | simple, moderate, complex |
| ai_estimated_files | text[] | Expected file changes |
| autonomy_score | integer | 1-5 confidence score |
| resolution_notes | text | What was done to fix it |
| testing_instructions | text | Step-by-step test guide for admin |
| testing_url | text | Direct URL to test |
| testing_result | text | pass, fail, partial (set by admin) |
| image_urls | text[] | Screenshot URLs |
| created_at | timestamptz | Submission time |
| updated_at | timestamptz | Last update |
| resolved_at | timestamptz | When resolved |
| resolved_by | uuid | Who resolved |
| user_confirmed_at | timestamptz | User confirmation |

**Table: `feedback_comments`**

| Column | Type | Notes |
|--------|------|-------|
| id | uuid | PK |
| feedback_id | uuid | FK to user_feedback (CASCADE delete) |
| author_type | text | user, admin, ai_agent |
| author_name | text | Display name |
| content | text | Comment body |
| created_at | timestamptz | When posted |
