// import { createEntitySelectors, useAppDispatch, useAppSelector, useEntityTools } from '@/lib/redux';
// import { EntityKeys, MatrxRecordId } from '@/types';
// import { useCallback, useEffect, useMemo } from 'react';
// import { DefinedRelationship, RelatedDataManager, RelationshipDefinition, RelationshipMapper } from './relationshipDefinitions';
// import { toMatrxIdFromValue } from '@/lib/redux/entity/utils/entityPrimaryKeys';
// import { useDirectCreateRecord } from '../unsaved-records/useDirectCreate';
// import { useJoinedDeleteRecord } from './useJoinedRecords';

// export function useFetchDependentRecords(entityName: EntityKeys, recordIds: MatrxRecordId[]) {
//     const dispatch = useAppDispatch();
//     const { actions } = useEntityTools(entityName);

//     useEffect(() => {
//         if (recordIds.length > 0) {
//             dispatch(
//                 actions.getOrFetchSelectedRecords({
//                     matrxRecordIds: recordIds,
//                     fetchMode: 'fkIfk',
//                 })
//             );
//         }
//     }, [recordIds, dispatch, actions]);
// }

// export type EntityRoles = {
//     parent: EntityKeys;
//     child: EntityKeys;
//     join: DefinedRelationship;
//     childTwo?: EntityKeys;
//     childThree?: EntityKeys;
// };

// export function useParentRelationship(config: EntityRoles, parentId: string) {
//     const joinEntity = config.join
//     const parentEntity = config.parent;
//     const childEntity = config.child;
//     const selectors = createEntitySelectors(joinEntity);
//     const records = useAppSelector(selectors.selectAllEffectiveRecords);

//     const mapper = useMemo(() => {
//         const m = new RelationshipMapper(joinEntity);
//         m.setParentEntity(parentEntity);
//         m.setData(records);
//         m.setParentId(parentId);
//         return m;
//     }, [joinEntity, parentEntity, records, parentId]);

//     const JoiningEntityRecords = mapper.getJoinRecords();
//     const joiningMatrxIds = mapper.getJoinMatrxIds();
//     const childIds = mapper.getChildMatrxIds();
//     const childMatrxIds = mapper.getChildMatrxIds();
//     const parentMatrxid = toMatrxIdFromValue(parentEntity, parentId);

//     useFetchDependentRecords(childEntity, childMatrxIds);

//     const { isDeleting, deleteMatrxIdWithChild, deletePkWithChild } = useJoinedDeleteRecord(
//         relationshipDefinition,
//         selectors,
//         joinEntity,
//         JoiningEntityRecords,
//         childEntity
//     );

//     const createRecords = useCreateRelatedRecords({ joinEntityName: joinEntity, childEntity: childEntity, parentId });

//     return { mapper, JoiningEntityRecords, joiningMatrxIds, childIds, childMatrxIds, parentMatrxid, parentId, createRecords };
// }

// interface RawData {
//     child: Record<string, unknown>;
//     joining?: Record<string, unknown>;
// }

// interface UseRelationshipCreateOptions {
//     joinEntityName: DefinedRelationship;
//     childEntity: EntityKeys;
//     parentId: unknown;
//     onSuccess?: () => void;
//     onError?: (error: Error) => void;
// }

// const OPERATION_DELAY = 50;

// export const useCreateRelatedRecords = ({ joinEntityName, childEntity, parentId, onSuccess, onError }: UseRelationshipCreateOptions) => {
//     const relatedData = useMemo(() => new RelatedDataManager(joinEntityName, { joiningEntity: true, child: true }), [joinEntityName]);

//     const createChildRecord = useDirectCreateRecord({
//         entityKey: childEntity,
//         onSuccess: () => onSuccess?.(),
//         onError,
//     });

//     const createJoiningRecord = useDirectCreateRecord({
//         entityKey: joinEntityName,
//         onSuccess: () => onSuccess?.(),
//         onError,
//     });

//     const createRecords = useCallback(
//         async (data: RawData) => {
//             try {
//                 relatedData.resetAutoGeneratedIds();
//                 const { childEntity: childPayload, joiningEntity: joinPayload } = relatedData.createEntityWithRelationship(
//                     parentId,
//                     data.child,
//                     data.joining ?? {}
//                 );

//                 await createChildRecord({ data: childPayload });
//                 await new Promise((resolve) => setTimeout(resolve, OPERATION_DELAY));
//                 await createJoiningRecord({ data: joinPayload });
//             } catch (error) {
//                 onError?.(error as Error);
//                 throw error;
//             }
//         },
//         [createJoiningRecord, createChildRecord, relatedData, parentId, onError]
//     );

//     return createRecords;
// };
