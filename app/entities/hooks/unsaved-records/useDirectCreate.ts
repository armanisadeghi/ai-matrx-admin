import { useCallback, useMemo } from 'react';
import { useEntityToasts, useEntityTools } from '@/lib/redux';
import { EntityKeys } from '@/types';
import { callbackManager } from '@/utils/callbackManager';
import { v4 as uuidv4 } from 'uuid';
import { DefinedRelationship, RelatedDataManager } from '../relationships/relationshipDefinitions';

interface RawData {
    child: Record<string, unknown>;
    joining?: Record<string, unknown>;
}
interface UseCoordinatedCreateOptions {
    joiningEntityKey: EntityKeys;
    childEntityKey: EntityKeys;
    onSuccess?: () => void;
    onError?: (error: Error) => void;
}

export const useRelationshipCreate = (joinEntityName: DefinedRelationship, childEntity: EntityKeys, parentId: unknown) => {
    const relatedData = useMemo(() => new RelatedDataManager(joinEntityName, { joiningEntity: true, child: true }), [joinEntityName]);

    const coordinated = useCoordinatedCreate({
        joiningEntityKey: joinEntityName,
        childEntityKey: childEntity,
        onSuccess: () => {
            console.log('Relationship created successfully');
        },
        onError: (error) => {
            console.warn('Error creating relationship', error, joinEntityName, childEntity, relatedData);
        },
    });

    const createRelationship = useCallback(
        async (data: RawData) => {
            relatedData.resetAutoGeneratedIds();
            const { childEntity: childPayload, joiningEntity: joinPayload } = relatedData.createEntityWithRelationship(
                parentId,
                data.child,
                data.joining ?? {}
            );
            // Send flattened data to the coordinated create
            return coordinated({
                joining: joinPayload,
                child: childPayload,
            });
        },
        [coordinated, relatedData, parentId]
    );

    return createRelationship;
};

export const useRelationshipCreateManualId = (joinEntityName: DefinedRelationship, childEntity: EntityKeys, parentId: unknown) => {
    const relatedData = useMemo(() => new RelatedDataManager(joinEntityName, { joiningEntity: true }), [joinEntityName]);

    const coordinated = useCoordinatedCreate({
        joiningEntityKey: joinEntityName,
        childEntityKey: childEntity,
        onSuccess: () => {
            console.log('Relationship created successfully');
        },
        onError: (error) => {
            console.warn('Error creating relationship', error, joinEntityName, childEntity, relatedData);
        },
    });

    const createRelationship = useCallback(
        async (data: RawData) => {

            relatedData.setChildId(data.child.id as string);
            relatedData.setParentId(parentId as string);
            const { childEntity: childPayload, joiningEntity: joinPayload } = relatedData.createEntityWithRelationship(
                parentId,
                data.child,
                data.joining ?? {}
            );
            // Send flattened data to the coordinated create
            return coordinated({
                joining: joinPayload,
                child: childPayload,
            });
        },
        [coordinated, relatedData, parentId]
    );

    return createRelationship;
};


const delay = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));

export const useCoordinatedCreate = <T extends Record<string, any>>({ joiningEntityKey, childEntityKey, onSuccess, onError }: UseCoordinatedCreateOptions) => {
    const createChildRecord = useDirectCreateRecord<T>({
        entityKey: childEntityKey,
        onSuccess: () => {
            onSuccess?.();
        },
        onError,
    });

    const createJoiningRecord = useDirectCreateRecord<T>({
        entityKey: joiningEntityKey,
        onSuccess: () => {
            onSuccess?.();
        },
        onError,
    });

    return useCallback(
        async (payload: { joining: Record<string, unknown>; child: Record<string, unknown> }) => {
            try {
                await createChildRecord({
                    data: payload.child,
                });

                // Add a small delay (50ms) between operations
                await delay(50);

                await createJoiningRecord({
                    data: payload.joining,
                });
            } catch (error) {
                onError?.(error as Error);
                throw error;
            }
        },
        [createJoiningRecord, createChildRecord, onError]
    );
};

// Only wrap with 'data' at the final step where it's required
export const useDirectCreateRecord = <T extends Record<string, any>>({ entityKey, onSuccess, onError }: UseDirectCreateRecordOptions) => {
    const { actions, dispatch, store, selectors } = useEntityTools(entityKey);
    const entityToasts = useEntityToasts(entityKey);

    return useCallback(
        async ({ data }: { data: Record<string, unknown> }) => {
            let tempId: string;

            try {
                tempId = 'new-record-' + uuidv4();

                console.log(data);

                dispatch(
                    actions.startRecordCreationWithData({
                        tempId,
                        initialData: data,
                    })
                );

                const createPayload = selectors.selectCreatePayload(store.getState(), tempId);
                dispatch(actions.addPendingOperation(tempId));

                dispatch(
                    actions.createRecord({
                        ...createPayload,
                        callbackId: callbackManager.register(({ success, error }) => {
                            dispatch(actions.removePendingOperation(tempId));
                            if (success) {
                                entityToasts.handleCreateSuccess();
                                onSuccess?.(tempId);
                            } else {
                                entityToasts.handleError(error, 'create');
                                onError?.(error);
                            }
                        }),
                    })
                );

                return tempId;
            } catch (error) {
                if (tempId!) {
                    dispatch(actions.removePendingOperation(tempId));
                }
                entityToasts.handleError(error as Error, 'create');
                onError?.(error as Error);
                throw error;
            }
        },
        [dispatch, actions, selectors, store, entityToasts, onSuccess, onError]
    );
};

interface UseDirectCreateRecordOptions {
    entityKey: EntityKeys;
    onSuccess?: (recordId: string) => void;
    onError?: (error: Error) => void;
}

export const useDirectCreateRecordWithTemp = <T extends Record<string, any>>({ entityKey, onSuccess, onError }: UseDirectCreateRecordOptions) => {
    const { actions, dispatch, store, selectors } = useEntityTools(entityKey);
    const entityToasts = useEntityToasts(entityKey);

    return useCallback(
        async ({ tempId, data }: { tempId: string; data: Partial<T> }) => {
            dispatch(
                actions.startRecordCreationWithData({
                    tempId,
                    initialData: data,
                })
            );

            const createPayload = selectors.selectCreatePayload(store.getState(), tempId);
            dispatch(actions.addPendingOperation(tempId));

            try {
                dispatch(
                    actions.createRecord({
                        ...createPayload,
                        callbackId: callbackManager.register(({ success, error }) => {
                            dispatch(actions.removePendingOperation(tempId));

                            if (success) {
                                entityToasts.handleCreateSuccess();
                                onSuccess?.(tempId);
                            } else {
                                entityToasts.handleError(error, 'create');
                                onError?.(error);
                            }
                        }),
                    })
                );

                return tempId;
            } catch (error) {
                dispatch(actions.removePendingOperation(tempId));
                entityToasts.handleError(error as Error, 'create');
                onError?.(error as Error);
                throw error;
            }
        },
        [dispatch, actions, selectors, store, entityToasts, onSuccess, onError]
    );
};
