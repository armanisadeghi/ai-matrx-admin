import { useCallback, useMemo } from 'react';
import { createRecordKey, useAppSelector, useEntityTools } from '@/lib/redux';
import { EntityData, EntityKeys, MatrxRecordId } from '@/types/entityTypes';
import { DefinedRelationship, RelatedDataManager } from '../relationships/relationshipDefinitions';
import { useSequentialCreate } from './useSequentialCreate';


export interface ProcessedResults {
    childRecord: EntityData<EntityKeys>;
    joinRecord: EntityData<EntityKeys>;
    childMatrxRecordId: MatrxRecordId;
    joinMatrxRecordId: MatrxRecordId;
}

export const processReturnResults = (results: RelationshipCreateResult[]): ProcessedResults => {
    const childRecord = results[0].childRecord.data as EntityData<EntityKeys>;
    const joinRecord = results[0].joinRecord.data as EntityData<EntityKeys>;
    const childMatrxRecordId = results[0].childRecord.matrxRecordId as MatrxRecordId;
    const joinMatrxRecordId = results[0].joinRecord.matrxRecordId as MatrxRecordId;

    return {
        childRecord,
        joinRecord,
        childMatrxRecordId,
        joinMatrxRecordId,
    };
};



interface RawData {
    child: Record<string, unknown>;
    joining?: Record<string, unknown>;
    parentId?: unknown;
}

interface RecordWithKey {
    matrxRecordId: MatrxRecordId;
    data: Record<string, unknown>;
}

export interface RelationshipCreateResult {
    childRecord: RecordWithKey;
    joinRecord: RecordWithKey;
    childMatrxRecordId: MatrxRecordId;
    joinMatrxRecordId: MatrxRecordId;
}

export interface RelationshipCreateCallbacks {
    onSuccess?: (result: RelationshipCreateResult) => void;
    onError?: (error: Error) => void;
    showIndividualToasts?: boolean;
    showCombinedToast?: boolean;
}

export const useRelationshipDirectCreate = (
    joinEntity: DefinedRelationship,
    childEntity: EntityKeys,
    initialParentId?: unknown,
    defaultShowIndividualToasts?: boolean,
    defaultShowCombinedToast?: boolean
) => {
    const relatedData = useMemo(() => new RelatedDataManager(joinEntity, { joiningEntity: true, child: true }), [joinEntity]);

    const { selectors: childSelectors } = useEntityTools(childEntity);
    const { selectors: joinSelectors } = useEntityTools(joinEntity);

    const childPkMetadata = useAppSelector(childSelectors.selectPrimaryKeyMetadata);
    const childNativeFields = useAppSelector(childSelectors.selectNativeFieldNames);
    const joinPkMetadata = useAppSelector(joinSelectors.selectPrimaryKeyMetadata);
    const joinNativeFields = useAppSelector(joinSelectors.selectNativeFieldNames);

    const coordinated = useSequentialCreate({
        firstEntity: childEntity,
        secondEntity: joinEntity,
        showIndividualToasts: defaultShowIndividualToasts,
        showCombinedToast: defaultShowCombinedToast,
    });

    const filterPayloadByNativeFields = (payload: Record<string, unknown>, nativeFields: string[]) => {
        return Object.fromEntries(
            Object.entries(payload).filter(([key]) => nativeFields.includes(key))
        );
    };

    const createRelationship = useCallback(
        async (data: RawData, callbacks?: RelationshipCreateCallbacks, filter?: boolean): Promise<RelationshipCreateResult | void> => {
            try {
                const childPkFields = childPkMetadata.fields;
                const primaryKeyField = childPkFields[0];
                const childId = data.child[primaryKeyField];
                const effectiveParentId = data.parentId ?? initialParentId;

                if (!effectiveParentId) {
                    throw new Error('Parent ID must be provided either during hook initialization or in the create call');
                }

                relatedData.resetAutoGeneratedIds();

                const { childEntity: childPayload, joiningEntity: joinPayload } = relatedData.createEntityWithRelationship(
                    effectiveParentId,
                    data.child,
                    data.joining ?? {},
                    childId,
                    filter
                );
    
                console.log('Child payload:', childPayload);
                console.log('Join payload:', joinPayload);


                const cleanChildPayload = filterPayloadByNativeFields(childPayload, childNativeFields);
                const cleanJoinPayload = filterPayloadByNativeFields(joinPayload, joinNativeFields);
                console.log('Cleaned child payload:', cleanChildPayload);
                console.log('Cleaned join payload:', cleanJoinPayload);

                const childMatrxRecordId = createRecordKey(childPkMetadata, cleanChildPayload);
                const joinMatrxRecordId = createRecordKey(joinPkMetadata, cleanJoinPayload);

                const { firstResult: childData, secondResult: joinData } = await coordinated({
                    firstData: cleanChildPayload,
                    secondData: cleanJoinPayload,
                    firstMatrxRecordId: childMatrxRecordId,
                    secondMatrxRecordId: joinMatrxRecordId,
                    showIndividualToasts: callbacks?.showIndividualToasts,
                    showCombinedToast: callbacks?.showCombinedToast,
                });

                const result: RelationshipCreateResult = {
                    childRecord: childData as RecordWithKey,
                    joinRecord: joinData as RecordWithKey,
                    childMatrxRecordId,
                    joinMatrxRecordId,
                };

                console.log('result', result)

                if (result.childRecord.matrxRecordId !== result.childMatrxRecordId) {
                    console.warn(
                        'Child record key mismatch:',
                        '\nRecord Key:', result.childRecord.matrxRecordId,
                        '\nMatrx ID:', result.childMatrxRecordId
                    );
                }

                if (result.joinRecord.matrxRecordId !== result.joinMatrxRecordId) {
                    console.warn(
                        'Join record key mismatch:',
                        '\nRecord Key:', result.joinRecord.matrxRecordId,
                        '\nMatrx ID:', result.joinMatrxRecordId
                    );
                }

                console.log('----------- Created relationship:', result);

                callbacks?.onSuccess?.(result);
                return result;
            } catch (error) {
                callbacks?.onError?.(error as Error);
                throw error;
            }
        },
        [relatedData, initialParentId, childPkMetadata, joinPkMetadata, coordinated, childNativeFields, joinNativeFields]
    );

    return createRelationship;
}