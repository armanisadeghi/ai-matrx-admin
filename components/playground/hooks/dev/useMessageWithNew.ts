import React, { useCallback, useState } from 'react';
import { DataBrokerDataRequired, MatrxRecordId, MessageBrokerDataRequired, MessageTemplateDataOptional } from '@/types';
import { GetOrFetchSelectedRecordsPayload, useAppDispatch, useAppSelector, useEntityTools } from '@/lib/redux';
import { processJoinedData, RelationshipDefinition } from '@/app/entities/hooks/relationships/utils';
import { useActiveJoinedRecords } from '@/app/entities/hooks/relationships/useActiveJoinedRecords';
import { useJoinedRecordsActiveParent } from '@/app/entities/hooks/relationships/useJoinedRecords';
import { ProcessedRecipeMessages } from '../../panel-manager/types';
import { useMessageReordering } from '../messages/useMessageReordering';

const messageRelationshipDefinition: RelationshipDefinition = {
    parentEntity: {
        entityKey: 'recipe',
        referenceField: 'id',
    },
    childEntity: {
        entityKey: 'messageTemplate',
        referenceField: 'id',
    },
    joiningEntity: {
        entityKey: 'recipeMessage',
        parentField: 'recipeId',
        childField: 'messageId',
        orderPositionField: 'order',
    },
};

const brokerRelationshipDefinition: RelationshipDefinition = {
    parentEntity: {
        entityKey: 'messageTemplate',
        referenceField: 'id',
    },
    childEntity: {
        entityKey: 'dataBroker',
        referenceField: 'id',
    },
    joiningEntity: {
        entityKey: 'messageBroker',
        parentField: 'messageId',
        childField: 'brokerId',
        defaultValueField: 'defaultValue',
    },
};


export function useMessageTemplatesWithNew() {
    const [needsReprocess, setNeedsReprocess] = useState(false);

    const {
        matchingChildRecords: messages,
        childMatrxIds: messageMatrxIds,
        JoiningEntityRecords: recipeMessages,
        deletePkWithChild: deleteMessageById,
        deleteMatrxIdWithChild: deleteMessageByMatrxId,
        createRelatedRecords: createMessageTemplates,
        parentId: acticeRecipeId,
    } = useJoinedRecordsActiveParent(messageRelationshipDefinition);

    // const { updateRecord: savePermanentRecordChanges } = useUpdateRecord("messageTemplate");

    // Add state for managing unsaved messages
    const [unsavedMessageIds, setUnsavedMessageIds] = useState<string[]>([]);

    // Get the unsaved message management tools
    const { start, startWithData, updateBoth, create, isParentLoading } = createMessageTemplates; // isParentLoading is important because if it's not yet loaded, we don't want to trigger creating two new records to start.

    // Process messages with joining data (keep existing)
    const processedMessages = React.useMemo(() => {
        return processJoinedData({
            childRecords: messages,
            joiningRecords: recipeMessages,
            relationshipDefinition: messageRelationshipDefinition,
        }) as ProcessedRecipeMessages[];
    }, [messages, recipeMessages, needsReprocess]);

    const {
        handleDragDrop,
    } = useMessageReordering(processedMessages, () => setNeedsReprocess(true));
    
    // Keep all existing broker relationship management
    const {
        matchingChildRecords: brokers,
        JoiningEntityRecords: messageBrokers,
        childMatrxIds: brokerMatrxIds,
        childActions: brokerActions,
    } = useActiveJoinedRecords(brokerRelationshipDefinition);

    // Keep existing broker processing
    const processedBrokers = React.useMemo(() => {
        return processJoinedData({
            childRecords: brokers,
            joiningRecords: messageBrokers,
            relationshipDefinition: brokerRelationshipDefinition,
        });
    }, [brokers, messageBrokers]) as DataBrokerDataRequired[];

    // Keep existing broker fetching
    const dispatch = useAppDispatch();
    const fetchBrokersPayload = React.useMemo<GetOrFetchSelectedRecordsPayload>(
        () => ({
            matrxRecordIds: brokerMatrxIds,
            fetchMode: 'fkIfk',
        }),
        [brokerMatrxIds]
    );

    const fetchDependentRecords = useCallback(() => {
        if (brokerMatrxIds.length > 0) {
            dispatch(brokerActions.getOrFetchSelectedRecords(fetchBrokersPayload));
        }
    }, [dispatch, brokerActions, brokerMatrxIds, fetchBrokersPayload]);

    // Add new message management methods
    const addMessage = useCallback(
        (newMessage: MessageTemplateDataOptional) => {
            const nextOrder = processedMessages.length;

            // Split the data between child and joining tables
            const { role, type, content } = newMessage; // We do not provide the id. The id is generated by the system.

            const joinId = startWithData(
                // Message template data
                { role, type, content },
                // Recipe message data
                { order: nextOrder }
            );

            if (joinId) {
                setUnsavedMessageIds((prev) => [...prev, newMessage.id]);
            }

            return joinId;
        },
        [startWithData, processedMessages.length]
    );

    const updateMessage = useCallback(
        (messageId: string, updates: Partial<ProcessedRecipeMessages>) => {
            // You have to be careful with using 'id' or 'messageId'. Everything we do should be with matrxRecordId, not id.
            if (unsavedMessageIds.includes(messageId)) {
                // Separate the updates between the two tables
                const { order, recipeId, ...messageUpdates } = updates;

                updateBoth({
                    child: messageUpdates,
                    joined: order !== undefined ? { order } : undefined,
                });
            }
        },
        [updateBoth, unsavedMessageIds]
    );

    const saveUnsavedMessage = useCallback(
        (messageId: string) => {
            if (unsavedMessageIds.includes(messageId)) {
                create();
                setUnsavedMessageIds((prev) => prev.filter((id) => id !== messageId));
            } else {
                // savePermanentRecordChanges(matrxRecordId);
                console.log('Save permanent record changes not implemented yet');
            }
        },
        [create, unsavedMessageIds]
    );

    return {
        acticeRecipeId,
        // Keep all existing returns
        messages: processedMessages as ProcessedRecipeMessages[], // Now properly typed as joined data
        messageMatrxIds,
        brokers: processedBrokers,
        fetchDependentRecords,
        deleteMessageById,
        deleteMessageByMatrxId,
        createMessageTemplates,
        handleDragDrop,
        // Add new message management methods
        addMessage,
        updateMessage,
        saveUnsavedMessage,
        hasUnsavedMessages: unsavedMessageIds.length > 0,
        unsavedMessageIds,
    };
}

export type UseRecipeMessagesHook = ReturnType<typeof useMessageTemplatesWithNew>;